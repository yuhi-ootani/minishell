en.subject.pdf
include
libft
Makefile
minishell
output.txt
srcs
tests
trash


#define MAX_COMMANDS 1024

void	single_command_executor(t_command *command, char **envp)
{
	pid_t pids[MAX_COMMANDS];
	size_t i = 0;
	static int (*builtin_funcs[])(t_command *) = {ft_echo, ft_cd, ft_pwd,
		ft_export, ft_unset, ft_env, ft_exit};
	int pipefd[2];
	int in_fd = STDIN_FILENO;
	// pid_t pid;
	int status;

	while (command)
	{
		if (command->next)
		{
			if (pipe(pipefd) < 0)
			{
				perror("pipe");
				return ;
			}
		}
		pids[i] = fork();
		if (pids[i] == 0)
		{
			if (in_fd != STDIN_FILENO)
			{
				dup2(in_fd, STDIN_FILENO);
				close(in_fd);
			}
			if (command->next)
			{
				dup2(pipefd[1], STDOUT_FILENO);
				close(pipefd[0]);
				close(pipefd[1]);
			}
			handle_redirection(command);
			t_buildin_cmd buildin_index = is_builtin(command->args[0]);

			if (buildin_index != FT_NOT_BUILDIN)
				builtin_funcs[buildin_index](command); // Execute the function
			else
				execute_external_command(command, envp);
		}
		else if (pids[i] < 0)
		{
			perror("fork");     // modified
			exit(EXIT_FAILURE); // modified
		}

		// waitpid(pid, &status, 0);

		if (in_fd != STDIN_FILENO)
			close(in_fd);

		if (command->next)
		{
			close(pipefd[1]);
			in_fd = pipefd[0];
		}
		command = command->next;
		i++;
	}

	// Wait for all children after forking them all.
	for (int j = 0; j < i; j++)
		waitpid(pids[j], &status, 0);
}